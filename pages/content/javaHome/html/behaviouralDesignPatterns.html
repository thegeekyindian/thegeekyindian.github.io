<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>The Geeky Indian</title><link href="https://fonts.googleapis.com" rel="preconnect"><style type="text/css"></style><noscript><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,200i,300,300i,400,400i,600,600i,700,700i,900,900i" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Merriweather:300,300i,400,400i,700,700i,900,900i" rel="stylesheet"></noscript><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,200i,300,300i,400,400i,600,600i,700,700i,900,900i" rel="preload" as="style" onload="this.rel='stylesheet'"><link href="https://fonts.googleapis.com/css?family=Merriweather:300,300i,400,400i,700,700i,900,900i" rel="preload" as="style" onload="this.rel='stylesheet'"></head><body><h2 id="introduction" level="2">Introduction</h2><p><span class="highlight--red">Behavioral design patterns</span> deal with the interaction of objects in an object-oriented software application. This article discusses various behavioral design patterns that help objects cooperate and interact with each other. Behavioral Design Patterns provides a set of guidelines formulated by software pioneers that identify common communication patterns among objects and provide a way to solve commonly occurring <span class="highlight--red">object-interaction-related</span> problems in software design.</p><section class="main"><h2 id="what-is-a-behavioral-design-pattern-" level="2">What is a behavioral design pattern?</h2><p>Behaviour is how someone acts i.e., it consists of the tasks that one executes to interact in an environment. In object-oriented software development, the behaviour of different objects determines the relationship between them and also determines their ability to perform a certain task.</p><p>The ability of an object-oriented software application to accomplish a task depends upon the interaction of various objects and classes. To build efficient object-oriented software, we should follow some guidelines that describes how different objects and classes send messages to each other to make things happen. This is where Behavioral Design Patterns come into the picture. It is a collection of templates that revolve around designing the interaction between objects and classes.</p><p>Behavioral patterns follow the principle that the objects in an object-oriented application should be interconnected in such a way that hard coding can be avoided and the user input can be well handled. For this principle, the behavioral design patterns make use of loose coupling techniques to ensure a flexible and effective flow of information.</p><p>Loosely coupled object-oriented software systems are those in which the components (classes and objects) are weakly associated with each other. Due to this weak association between the components, the object interactions in loosely coupled systems are not as effective as that in tightly coupled systems. But, objects in a loosely coupled system are more independent and reusable as any changes made in one component have minimal effect on the existence or the performance of another component.</p><p></p><p>Hence, to take benefit from this extensibility of a loosely-coupled system, behavioral design patterns are used which can help objects cooperate and communicate with each other while they are loosely coupled. This effect can be noticed in the above figure where the two objects <strong><span class="highlight--red">O1</span></strong> and <strong><span class="highlight--red">O2</span></strong> are able to interact with each other (<strong><span class="highlight--red">O1</span></strong> and <strong><span class="highlight--red">O2</span></strong> sends messages <strong><span class="highlight--red">msg</span></strong> and <strong><span class="highlight--red">MSG</span></strong> to each other respectively), even in a loosely coupled configuration using Behavioral Design Patterns. This provides the flexibility and independence of objects in an application and also maintains the interactions between them. Making use of behavioral patterns can reduce complicated software design structures into a simpler cluster of interconnections between several objects.</p></section><section class="main"><h2 id="types-of-behavioral-design-patterns" level="2">Types of Behavioral Design Patterns</h2><p>There are 12 different types of behavioral patterns as described in the <a href="https://www.oreilly.com/library/view/design-patterns-elements/0201633612/" rel="nofollow" target="_blank" title="">Design Patterns: Elements of Reusable Object-Oriented Software</a> book (also called the <strong><span class="highlight--red">Gang of Four</span></strong>). Behavioral design patterns include:</p><h3 id="chain-of-responsibility-pattern" level="3">Chain of Responsibility Pattern</h3><p>It is a behavioral design pattern that allows us to pass a request between a chain of objects. Each object in the chain contains its processing logic that performs some action and decides the next object from the chain to delegate the work. It is used in decoupling the sender from the receiver.</p><p><strong>When to use Chain of Responsibility Pattern</strong></p><ul><li>When we wish to decouple the request's sender from its receiver.</li><li>When the request provided to the application can be handled by passing it to a series of objects.</li><li>When we need to enhance the flexibility of the duties assigned to objects.</li></ul><h3 id="command-pattern" level="3">Command Pattern</h3><p>It is a data-driven behavioral pattern that turns a request into a stand-alone object known as a <strong>command</strong>. It encapsulates all the information that is required to act i.e., it wraps the action and its required parameters together in an object. It is used to separate the object that invokes the operation from the object that operates.</p><p><strong>When to use Command Pattern</strong></p><ul><li>When we need to attach operations with objects using which we can queue operations, schedule their execution, or execute them remotely.</li><li>When we wish to implement reversible operations like undo and redo operations. Since the command pattern allows us to create objects that represent the actions that are to be performed in the application, we can create a list of tasks performed (list of command objects) and can undo or redo the task just by searching and executing the undo method of the last command object from the task list.</li></ul><h3 id="interpreter-pattern" level="3">Interpreter Pattern</h3><p>It is a behavioral pattern that is used to incorporate specialized computer language elements in programs to solve a specific set of problems. It is used to write simple programs that understand human-like syntax.</p><p><strong>When to use Interpreter Pattern</strong></p><ul><li>When we wish to provide human-like syntax to the clients and hide the application's structure complexity from the clients.</li><li>When we wish to define a grammatical representation for a domain-specific language and provide an interpreter to deal with this grammar.</li></ul><h3 id="iterator-pattern" level="3">Iterator Pattern</h3><p>An iterator pattern is a type of behavioral pattern that is used to sequentially access the elements of a collection without exposing its underlying or internal representation.</p><p><strong>When to use Iterator Pattern</strong></p><ul><li>When we wish to provide a way to access and traverse the elements of a collection without revealing the internal data structures to the clients.</li><li>When we want the application to traverse different data structures.</li></ul><h3 id="mediator-pattern" level="3">Mediator Pattern</h3><p>The mediator pattern is used to simplify the communication between multiple objects or classes. It provides a <strong>mediator class</strong> that handles all the interactions going on between different objects or classes. This pattern also promotes loose coupling by keeping objects from referring to each other explicitly.</p><p><strong>When to use Mediator Pattern</strong></p><ul><li>When the application consists of such a large number of objects that it becomes difficult to manage their references.</li><li>When it is difficult to change some classes because of the presence of tight coupling.</li></ul><h3 id="memento-pattern" level="3">Memento Pattern</h3><p>The memento pattern is used to implement the undo operation i.e., it allows us to save and restore an object to its previous state. It wraps the entire object state in a single object known as the <strong>Memento</strong> that allows the entire state to be saved and restored in a single action.</p><p><strong>When to use Memento Pattern</strong></p><ul><li>When we wish to produce the snapshots of the object's state to get the ability to restore the previous states of an object. The snapshot of an object represents its state at a particular instance in time in an object-oriented application.</li></ul><h3 id="observer-pattern" level="3">Observer Pattern</h3><p>An observer pattern is a behavioral pattern that is used to monitor the state of multiple objects or classes. It acts as a notifier of change to multiple classes. Using the observer pattern, the change in the state of an object is reflected among other objects in the application.</p><p><strong>When to use Observer Pattern</strong></p><ul><li>When modifications in the state of one object require a change in other objects.</li><li>When some objects must observe other objects only for a limited time or in specific cases.</li></ul><h3 id="state-pattern" level="3">State Pattern</h3><p>A state pattern is a behavioral design pattern that is used when a specific object needs to change its behaviour based on its internal state. It provides a way for an object to partially change its type at runtime. It appears as if the object changed its class at runtime.</p><p><strong>When to use State Pattern</strong></p><ul><li>When we have an object that behaves differently depending on its current state.</li><li>When we wish to implement different class behaviours according to the current values of the classâ€™s fields.</li></ul><h3 id="strategy-pattern" level="3">Strategy Pattern</h3><p>A strategy pattern or Policy pattern is a behavioral design pattern that helps us to write a generic code that gives us specific behaviour needed for given use cases. It allows us to select both the behaviour and the algorithm at runtime, based on the input of the client.</p><p><strong>When to use Strategy Pattern</strong></p><ul><li>When we have a use case of deciding how the objects will behave dynamically.</li><li>When we want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.</li></ul><h3 id="template-pattern" level="3">Template Pattern</h3><p>A template pattern is used to define the framework of an algorithm in the superclass and lets the subclasses redefine certain steps of an algorithm without changing the overall algorithm's structure.</p><p><strong>When to use Template Pattern</strong></p><ul><li>When several classes contain almost identical algorithms and we need to modify all the classes when there is a change in the algorithm.</li><li>When we want to allow the clients to extend only particular steps of an algorithm, but not the whole algorithm or its structure.</li></ul><h3 id="visitor-pattern" level="3">Visitor Pattern</h3><p>The visitor design pattern is used to separate an algorithm from the object structure on which it operates. It allows us to define and add new operations to the existing classes without affecting the existing structure.</p><p><strong>When to use Visitor Pattern</strong></p><ul><li>When we wish to perform an operation on all the elements of a complex object structure.</li><li>When we wish to extend the interface of the primary type by creating a separate class hierarchy.</li></ul><h3 id="null-object-pattern" level="3">Null Object Pattern</h3><p>A null object pattern is used to design a null object that conveys the absence of an object or acts as the default value of an object. It is used to minimize the null-checks in an application.</p><p><strong>When to use Null Object Pattern</strong></p><ul><li>When we want to minimize the null-checks in an application.</li><li>When we want to perform a null-check to skip the execution or perform a default action.</li></ul></section><section class="main"><h2 id="what-are-the-problems-solved-by-behavioral-design-patterns-" level="2">What are the Problems Solved by Behavioral Design Patterns?</h2><ul><li>It reduces the complexity of communication between the objects.</li><li>It provides the best object interaction principles of software development.</li><li>It reduces the coupling between the senders and the receivers and enables better communication flexibility in the application.</li><li>It is used to save the number of resources being used by an application as better object interaction leads to better task execution.</li></ul></section><section class="summary"><h2 id="conclusion" level="2">Conclusion</h2><p>In this article we learned:</p><ul><li>What is a behavioral design pattern?</li><li>How each behavioral design pattern differs from one another and the specific use case in which a pattern is applied.</li><li>Finally, we have discussed the problems that are solved by behavioral design patterns and why it is efficient in building an object-oriented application.</li></ul></section><style aria-hidden="true">.t41b7e627-9c69-4dc9-8082-803d07b8c232{color:#fff;background:#222;border:1px solid transparent;border-radius:undefinedpx;padding:8px 21px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-top{margin-top:-10px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-top::before{content:"";background-color:inherit;position:absolute;z-index:2;width:20px;height:12px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-top::after{content:"";position:absolute;width:10px;height:10px;border-top-right-radius:undefinedpx;border:1px solid transparent;background-color:#222;z-index:-2;bottom:-6px;left:50%;margin-left:-6px;transform:rotate(135deg)}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-bottom{margin-top:10px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-bottom::before{content:"";background-color:inherit;position:absolute;z-index:-1;width:18px;height:10px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-bottom::after{content:"";position:absolute;width:10px;height:10px;border-top-right-radius:undefinedpx;border:1px solid transparent;background-color:#222;z-index:-2;top:-6px;left:50%;margin-left:-6px;transform:rotate(45deg)}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-left{margin-left:-10px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-left::before{content:"";background-color:inherit;position:absolute;z-index:-1;width:10px;height:18px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-left::after{content:"";position:absolute;width:10px;height:10px;border-top-right-radius:undefinedpx;border:1px solid transparent;background-color:#222;z-index:-2;right:-6px;top:50%;margin-top:-6px;transform:rotate(45deg)}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-right{margin-left:10px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-right::before{content:"";background-color:inherit;position:absolute;z-index:-1;width:10px;height:18px}.t41b7e627-9c69-4dc9-8082-803d07b8c232.place-right::after{content:"";position:absolute;width:10px;height:10px;border-top-right-radius:undefinedpx;border:1px solid transparent;background-color:#222;z-index:-2;left:-6px;top:50%;margin-top:-6px;transform:rotate(-135deg)}</style><script type="text/javascript">/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(e){"use strict";var n=function(n,t,o){function i(e){if(a.body)return e();setTimeout(function(){i(e)})}function r(){l.addEventListener&&l.removeEventListener("load",r),l.media=o||"all"}var d,a=e.document,l=a.createElement("link");if(t)d=t;else{var f=(a.body||a.getElementsByTagName("head")[0]).childNodes;d=f[f.length-1]}var s=a.styleSheets;l.rel="stylesheet",l.href=n,l.media="only x",i(function(){d.parentNode.insertBefore(l,t?d:d.nextSibling)});var u=function(e){for(var n=l.href,t=s.length;t--;)if(s[t].href===n)return e();setTimeout(function(){u(e)})};return l.addEventListener&&l.addEventListener("load",r),l.onloadcssdefined=u,u(r),l};"undefined"!=typeof exports?exports.loadCSS=n:e.loadCSS=n}("undefined"!=typeof global?global:this);
/*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */
!function(t){if(t.loadCSS){var e=loadCSS.relpreload={};if(e.support=function(){try{return t.document.createElement("link").relList.supports("preload")}catch(t){return!1}},e.poly=function(){for(var e=t.document.getElementsByTagName("link"),r=0;r<e.length;r++){var n=e[r];"preload"===n.rel&&"style"===n.getAttribute("as")&&(t.loadCSS(n.href,n,n.getAttribute("media")),n.rel=null)}},!e.support()){e.poly();var r=t.setInterval(e.poly,300);t.addEventListener&&t.addEventListener("load",function(){e.poly(),t.clearInterval(r)}),t.attachEvent&&t.attachEvent("onload",function(){t.clearInterval(r)})}}}(this);</script></body></html>